<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

 Java 8 中的 Streams API 详解

Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），
或者大批量数据操作 (bulk data operation)。
Stream API 借助于同样新出现的 Lambda 表达式，极大的提高编程效率和程序可读性。
同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。
通常编写并行代码很难而且容易出错, 但使用 Stream API 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。
所以说，Java 8 中首次出现的 java.util.stream 是一个函数式语言+多核时代综合影响的产物。



而 Java 的集合 API 中，仅仅有极少量的辅助型方法，更多的时候是程序员需要用 Iterator 来遍历集合，完成相关的聚合应用逻辑。
这是一种远不够高效、笨拙的方法。
在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：

//是一个list集合
    List<Transaction> groceryTransactions = new Arraylist<>();
    //取出集合中对应的对象
    for(Transaction t: transactions){
    if(t.getType() == Transaction.GROCERY){
    groceryTransactions.add(t);
    }
    }
    //对取出来的集合进行排序
    Collections.sort(groceryTransactions, new Comparator(){
    public int compare(Transaction t1, Transaction t2){
    return t2.getValue().compareTo(t1.getValue());
    }
    });
    //然后取出对应的id放入集合
    List<Integer> transactionIds = new ArrayList<>();
        for(Transaction t: groceryTransactions){
        transactionsIds.add(t.getId());
        }

    而在 Java 8 使用 Stream，代码更加简洁易读；而且使用并发模式，程序执行速度更快。

        List<Integer> transactionsIds = transactions.parallelStream().
            filter(t -> t.getType() == Transaction.GROCERY).
            sorted(comparing(Transaction::getValue).reversed()).
            map(Transaction::getId).
            collect(toList());

</body>
</html>